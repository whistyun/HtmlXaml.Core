<p>This is the second part of a two part series about building real-time web applications with server-sent events.</p>

<ul>
    <li><a href="http://bayn.es/real-time-web-applications-with-server-sent-events-pt-1/">Building Web Apps with Server-Sent Events - Part 1</a></li>
</ul>

<h2 id="reconnecting">Reconnecting</h2>

<p>In this post we are going to look at handling reconnection if the browser loses contact with the server. Thankfully the native JavaScript functionality for SSEs (the <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource">EventSource</a>) handles this natively. You just need to make sure that your server-side implementation supports the mechanism.</p>

<p>When the server reconnects your SSE end point it will send a special HTTP header <code>Last-Event-Id</code> in the reconnection request. In the previous part of this blog series we looked at just sending events with the <code>data</code> component. Which looked something like this:-</p>

<pre><code>data: The payload we are sending\n\n
</code></pre>

<p>Now while this is enough to make the events make it to your client-side implementation. We need more information to handle reconnection. To do this we need to add an event id to the output.</p>

<p>E.g.</p>

<pre><code>id: 1439887379635\n
data: The payload we are sending\n\n
</code></pre>

<p>The important thing to understand here is that each event needs a unique identifier, so that the client can communicate back to the server (using the <code>Last-Event-Id</code> header) which was the last event it received on reconnection.</p>

<h2 id="persistence">Persistence</h2>

<p>In our previous example we used <a href="http://redis.io/topics/pubsub">Redis Pub/Sub</a> to inform <a href="https://nodejs.org/">Node.js</a> that it needs to push a new SSE to the client. Redis Pub/Sub is a topic communication which means it will be delivered to all <em>connected clients</em>, and then it will be removed from the topic. So there is no persistence for when clients reconnect. To implement this we need to add a persistence layer and so in this demo I have chosen to use <a href="https://www.mongodb.org/">MongoDB</a>.</p>

<p>Essentially we will be pushing events into both Redis and MongoDB. Redis will still be our method of initiating an SSE getting sent to the browser, but we will also be be storing that event into MongoDB so we can query it on a reconnection to get anything we've missed.</p>

<h2 id="thecode">The Code</h2>

<p>OK so let us look at how we can actually implement this.</p>

<h3 id="updateserverevent">Update ServerEvent</h3>

<p>We need to update the ServerEvent object to support having an <code>id</code> for an event.</p>

<pre><code>function ServerEvent(name) {
    this.name = name || "";
    this.data = "";
};

ServerEvent.prototype.addData = function(data) {
    var lines = data.split(/\n/);

    for (var i = 0; i &lt; lines.length; i++) {
        var element = lines[i];
        this.data += "data:" + element + "\n";
    }
}

ServerEvent.prototype.payload = function() {
    var payload = "";
    if (this.name != "") {
        payload += "id: " + this.name + "\n";
    }

    payload += this.data;
    return payload + "\n";
}
</code></pre>

<p>This is pretty straightforward string manipulation and won't impress anyone, but it is foundation for what will follow.</p>

<h3 id="storeeventsinmongodb">Store Events in MongoDB</h3>

<p>We need to update the <code>post.js</code> code to also store new events in MongoDB.</p>

<pre><code>app.put("/api/post-update", function(req, res) {
    var json = req.body;
    json.timestamp = Date.now();

    eventStorage.save(json).then(function(doc) {
        dataChannel.publish(JSON.stringify(json));
    }, errorHandling);

    res.status(204).end();
});
</code></pre>

<p>The <code>event-storage</code> module looks as follows:</p>

<pre><code>var Q = require("q"),
    config = require("./config"),
    mongo = require("mongojs"),
    db = mongo(config.mongoDatabase),
    collection = db.collection(config.mongoScoresCollection);

module.exports.save = function(data) {
    var deferred = Q.defer();
    collection.save(data, function(err, doc){
        if(err) {
            deferred.reject(err);
        }
        else {
            deferred.resolve(doc);
        }
    });

    return deferred.promise;
};
</code></pre>

<p>Here we are just using basic MongoDB commands to save a new event into the collection. Yep that is it, we are now additionally persisting the events so they can be retrieved later.</p>

<h3 id="retrievingeventsonreconnection">Retrieving Events on Reconnection</h3>

<p>When an <code>EventSource</code> reconnects after a disconnection it passes a special header <code>Last-Event-Id</code>. So we need to look for that and return the events that got broadcast while the client was disconnected.</p>

<pre><code>app.get("/api/updates", function(req, res){
    initialiseSSE(req, res);

    if (typeof(req.headers["last-event-id"]) != "undefined") {
        replaySSEs(req, res);
    }
});

function replaySSEs(req, res) {
    var lastId = req.headers["last-event-id"];

    eventStorage.findEventsSince(lastId).then(function(docs) {
        for (var index = 0; index &lt; docs.length; index++) {
            var doc = docs[index];
            var messageEvent = new ServerEvent(doc.timestamp);
            messageEvent.addData(doc.update);
            outputSSE(req, res, messageEvent.payload());
        }
    }, errorHandling);
};
</code></pre>

<p>What we are doing here is querying MongoDB for the events that were missed. We then iterate over them and output them to the browser.</p>

<p>The code for querying MongoDB is as follows:</p>

<pre><code>module.exports.findEventsSince = function(lastEventId) {
    var deferred = Q.defer();

    collection.find({
        timestamp: {$gt: Number(lastEventId)}
    })
    .sort({timestamp: 1}, function(err, docs) {
        if (err) {
            deferred.reject(err);
        }
        else {
            deferred.resolve(docs);
        }
    });

    return deferred.promise;
};
</code></pre>

<h2 id="testing">Testing</h2>

<p>To test this you will need to run both apps at the same time.</p>

<pre><code>node app.js
</code></pre>

<p>and </p>

<pre><code>node post.js
</code></pre>

<p>Once they are running open two browser windows <a href="http://localhost:8181/">http://localhost:8181/</a> and <a href="http://localhost:8082/api/post-update">http://localhost:8082/api/post-update</a></p>

<p>Now you can post updates as before. If you stop <code>app.js</code> but continue posting events, when you restart <code>app.js</code> within 10 seconds the <code>EventSource</code> will reconnect. This will deliver all missed events.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This very simple code gives you a very elegant and powerful push architecture to create real-time apps.</p>

<h3 id="improvements">Improvements</h3>

<p>A possible improvement would be to render the events from MongoDB server-side when the page is first output. Then we would get updates client-side as they are pushed to the browser.</p>

<h3 id="download">Download</h3>

<p>If you want to play with this application you can fork or browse it on <a href="https://github.com/baynezy/RealtimeDemo/tree/part-2">GitHub</a>.</p>

<h3>Some other HTML</h3>

<blockquote>
    <p class="right" align="right"><em>“Qualquer coisa que possas fazer ou sonhar, podes começá-la. A ousadia encerra em si mesma genialidade, poder e magia.<br />Ouse fazer, e o poder lhe será dado!”</em><br /><strong>— Johann Wolfgang von Goethe</strong></p>
</blockquote>